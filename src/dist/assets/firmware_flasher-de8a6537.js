import{e as P,F as z,G as A,d as xe,f as w,i,r as we,M as be,h as O,j as Q,T as f,k as Z,$ as t,l as ye,m as ge,A as Le,n as Me,P as re,u as _e,B as Ce,t as R,g as ae,s as ne,D as De,o as Ie,p as ke,q as Be,v as Re,w as Ne}from"./index-9715db87.js";import{g as Pe}from"./generate_filename-ef5ebf28.js";const Ue=134227968,ve=16384;function Ee(s,e){let a=0;for(;a<s.data.length&&e>=s.data[a].address+s.data[a].bytes;a++);const r={lineIndex:a};return s.data[a]&&e>=s.data[a].address&&(r.byteIndex=e-s.data[a].address),r}function Fe(s,e){let a=0;for(let r=0;r<4;r++)a+=s.data[e.lineIndex].data[e.byteIndex++]<<8*r,e.byteIndex>=s.data[e.lineIndex].bytes&&(e.lineIndex++,e.byteIndex=0);return a}function Oe(s){const e={},a=Ee(s,Ue);if(a.byteIndex!==void 0)return e.startAddress=Fe(s,a),e.endAddress=Fe(s,a),e}function $e(s,e,a){let r=a;const l=Ee(s,r);if(l.byteIndex!==void 0)throw new Error("Configuration area in firmware not free.");let n=0;for(;n<e.length;){const d=e.length-n,_={address:r,bytes:ve>d?d:ve,data:[]};if(s.data[l.lineIndex]&&_.address+_.bytes>s.data[l.lineIndex].address)throw new Error("Aborting data generation, free area too small.");for(let E=0;E<_.bytes;E++)_.data.push(e.charCodeAt(n++));r=r+_.bytes,s.data.splice(l.lineIndex++,0,_)}s.bytes_total+=e.length}const Ae="Custom defaults inserted in";class Ge{insertConfig(e,a){console.time(Ae);const r=`# Betaflight
${a}\0`,l=Oe(e);if(!l||l.endAddress-l.startAddress===0)return!1;if(r.length>=l.endAddress-l.startAddress)throw new Error(`Custom defaults area too small (${l.endAddress-l.startAddress} bytes), ${r.length+1} bytes needed.`);return $e(e,r,l.startAddress),console.timeEnd(Ae),!0}}const Se=function(){this.baud=void 0,this.port=void 0,this.onConnectCallback=void 0,this.onTimeoutCallback=void 0,this.onDisconnectCallback=void 0};Se.prototype.connect=function(s,e,a,r,l){const n=this;n.port=s,n.baud=e,n.onConnectCallback=a,n.onTimeoutCallback=r,n.onFailureCallback=l,P.connect(n.port,{bitrate:n.baud},function(d){if(d){const _=function(){P.disconnect(function(T){console.log("Disconnected"),O.clearListeners(),n.onTimeoutCallback()}),O.disconnect_cleanup()};z.resetState(),A.timeout_add("msp_connector",function(){xe.connectionValid||(w(i.getMessage("noConfigurationReceived")),_())},1e4),P.onReceive.addListener(we);const E=new be;O.listen(E.process_data.bind(E)),O.send_message(Q.MSP_API_VERSION,!1,!1,function(){xe.connectionValid=!0,A.timeout_remove("msp_connector"),console.log("Connected"),n.onConnectCallback()})}else w(i.getMessage("serialPortOpenFail")),n.onFailureCallback()})};Se.prototype.disconnect=function(s){self.onDisconnectCallback=s,P.disconnect(function(e){O.clearListeners(),console.log("Disconnected"),self.onDisconnectCallback(e)}),O.disconnect_cleanup()};const $=function(){this.callback=null,this.hex=null,this.verify_hex=[],this.handle=null,this.request={DETACH:0,DNLOAD:1,UPLOAD:2,GETSTATUS:3,CLRSTATUS:4,GETSTATE:5,ABORT:6},this.status={OK:0,errTARGET:1,errFILE:2,errWRITE:3,errERASE:4,errCHECK_ERASED:5,errPROG:6,errVERIFY:7,errADDRESS:8,errNOTDONE:9,errFIRMWARE:10,errVENDOR:11,errUSBR:12,errPOR:13,errUNKNOWN:14,errSTALLEDPKT:15},this.state={appIDLE:0,appDETACH:1,dfuIDLE:2,dfuDNLOAD_SYNC:3,dfuDNBUSY:4,dfuDNLOAD_IDLE:5,dfuMANIFEST_SYNC:6,dfuMANIFEST:7,dfuMANIFEST_WAIT_RESET:8,dfuUPLOAD_IDLE:9,dfuERROR:10},this.chipInfo=null,this.flash_layout={start_address:0,total_size:0,sectors:[]},this.transferSize=2048};$.prototype.connect=function(s,e,a,r){const l=this;l.hex=e,l.callback=r,l.options={erase_chip:!1,exitDfu:!1},a.exitDfu?l.options.exitDfu=!0:a.erase_chip&&(l.options.erase_chip=!0),l.upload_time_start=new Date().getTime(),l.verify_hex=[],f.firmware_flasher.flashingMessage(null,f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),chrome.usb.getDevices(s,function(n){n.length?(console.log(`USB DFU detected with ID: ${n[0].device}`),l.openDevice(n[0])):(console.log("USB DFU not found"),w(i.getMessage("stm32UsbDfuNotFound")))})};$.prototype.openDevice=function(s){const e=this;chrome.usb.openDevice(s,function(a){if(Z()){console.log("Failed to open USB device!"),w(i.getMessage("usbDeviceOpenFail")),A.operating_system==="Linux"&&w(i.getMessage("usbDeviceUdevNotice"));return}e.handle=a,w(i.getMessage("usbDeviceOpened",a.handle.toString())),console.log(`Device opened with Handle ID: ${a.handle}`),e.claimInterface(0)})};$.prototype.closeDevice=function(){const s=this;chrome.usb.closeDevice(s.handle,function(){Z()?(console.log("Failed to close USB device!"),w(i.getMessage("usbDeviceCloseFail"))):(w(i.getMessage("usbDeviceClosed")),console.log(`Device closed with Handle ID: ${s.handle.handle}`)),s.handle=null})};$.prototype.claimInterface=function(s){const e=this;chrome.usb.claimInterface(e.handle,s,function(){Z()?(console.log("Failed to claim USB device!"),e.cleanup()):(console.log(`Claimed interface: ${s}`),e.options.exitDfu?e.leave():e.upload_procedure(0))})};$.prototype.releaseInterface=function(s){const e=this;chrome.usb.releaseInterface(e.handle,s,function(){Z()?console.log(`Could not release interface: ${s}`):console.log(`Released interface: ${s}`),e.closeDevice()})};$.prototype.resetDevice=function(s){chrome.usb.resetDevice(this.handle,function(e){Z()?console.log(`Could not reset device: ${e}`):console.log(`Reset Device: ${e}`),s==null||s()})};$.prototype.getString=function(s,e){const a=this;chrome.usb.controlTransfer(a.handle,{direction:"in",recipient:"device",requestType:"standard",request:6,value:768|s,index:0,length:255},function(r){if(Z()){console.log(`USB getString failed! ${r.resultCode}`),e("",r.resultCode);return}var l=new DataView(r.data),n=l.getUint8(0),d="";for(let E=2;E<n;E+=2){var _=l.getUint16(E,!0);d+=String.fromCharCode(_)}e(d,r.resultCode)})};$.prototype.getInterfaceDescriptors=function(s,e){const a=this;chrome.usb.getConfiguration(a.handle,function(r){if(Z()){console.log("USB getConfiguration failed!"),e([],-200);return}let l=0;const n=[],d=function(){if(l<r.interfaces.length)a.getInterfaceDescriptor(l,function(_,E){if(E){e([],E);return}l++,a.getString(_.iInterface,function(T,D){if(D){e([],D);return}_.bInterfaceNumber===s&&n.push(T),d()})});else{e(n,0);return}};d()})};$.prototype.getInterfaceDescriptor=function(s,e){chrome.usb.controlTransfer(this.handle,{direction:"in",recipient:"device",requestType:"standard",request:6,value:512,index:0,length:18+s*9},function(a){if(Z()){console.log(`USB getInterfaceDescriptor failed! ${a.resultCode}`),e({},a.resultCode);return}const r=new Uint8Array(a.data,9+s*9),l={bLength:r[0],bDescriptorType:r[1],bInterfaceNumber:r[2],bAlternateSetting:r[3],bNumEndpoints:r[4],bInterfaceClass:r[5],bInterfaceSubclass:r[6],bInterfaceProtocol:r[7],iInterface:r[8]};e(l,a.resultCode)})};$.prototype.getFunctionalDescriptor=function(s,e){chrome.usb.controlTransfer(this.handle,{direction:"in",recipient:"interface",requestType:"standard",request:6,value:8448,index:0,length:255},function(a){if(Z()){console.log(`USB getFunctionalDescriptor failed! ${a.resultCode}`),e({},a.resultCode);return}const r=new Uint8Array(a.data),l={bLength:r[0],bDescriptorType:r[1],bmAttributes:r[2],wDetachTimeOut:r[4]<<8|r[3],wTransferSize:r[6]<<8|r[5],bcdDFUVersion:r[7]};e(l,a.resultCode)})};$.prototype.getChipInfo=function(s,e){this.getInterfaceDescriptors(0,function(r,l){if(l){e({},l);return}var n=function(_){_==="@External Flash /0x90000000/1001*128Kg,3*128Kg,20*128Ka"&&(_="@External Flash /0x90000000/998*128Kg,1*128Kg,4*128Kg,21*128Ka"),_==="@Option byte   /0x1FFFC000/01*4096 g"&&(_="@Option bytes   /0x1FFFC000/01*4096 g"),_==="@Option byte   /0x1FFFC000/01*512 g"&&(_="@Option bytes   /0x1FFFC000/01*512 g");var E=_.replace(/[^\x20-\x7E]+/g,""),T=E.split("/");if(T.length>3&&(console.log(`parseDescriptor: shrinking long descriptor "${_}"`),T.length=3),!T[0].startsWith("@"))return null;var D=T[0].trim().replace("@",""),V=parseInt(T[1]),N=[],u=0,v=T[2].split(",");if(v.length<1)return null;for(var m=0;m<v.length;m++){var F=v[m].split("*");if(F.length!==2)return null;var g=parseInt(F[0]),b=parseInt(F[1]);if(!b)return null;var S=F[1].slice(-2,-1);switch(S){case"M":b*=1024;case"K":b*=1024;break}N.push({num_pages:g,start_address:V+u,page_size:b,total_size:g*b}),u+=g*b}var y={type:D,start_address:V,sectors:N,total_size:u};return y},d=r.map(n).reduce(function(_,E,T){return _[E.type.toLowerCase().replace(" ","_")]=E,_},{});e(d,l)})};$.prototype.controlTransfer=function(s,e,a,r,l,n,d,_){const E=this;var T;if(typeof _>"u"?T=0:T=_,s==="in")chrome.usb.controlTransfer(E.handle,{direction:"in",recipient:"interface",requestType:"class",request:e,value:a,index:r,length:l,timeout:T},function(N){Z()&&console.log(`USB controlTransfer IN failed for request ${e}!`),N.resultCode&&console.log(`USB transfer result code: ${N.resultCode}`);var u=new Uint8Array(N.data);d(u,N.resultCode)});else{if(n){var D=new ArrayBuffer(n.length),V=new Uint8Array(D);V.set(n)}else var D=new ArrayBuffer(0);chrome.usb.controlTransfer(E.handle,{direction:"out",recipient:"interface",requestType:"class",request:e,value:a,index:r,data:D,timeout:T},function(N){Z()&&console.log(`USB controlTransfer OUT failed for request ${e}!`),N.resultCode&&console.log(`USB transfer result code: ${N.resultCode}`),d(N)})}};$.prototype.clearStatus=function(s){const e=this;function a(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(l){if(l[4]===e.state.dfuIDLE)s(l);else{var n=l[1]|l[2]<<8|l[3]<<16;setTimeout(r,n)}})}function r(){e.controlTransfer("out",e.request.CLRSTATUS,0,0,0,0,a)}a()};$.prototype.loadAddress=function(s,e,a){const r=this;r.controlTransfer("out",r.request.DNLOAD,0,0,0,[33,s&255,s>>8&255,s>>16&255,s>>24&255],function(){r.controlTransfer("in",r.request.GETSTATUS,0,0,6,0,function(l){if(l[4]===r.state.dfuDNBUSY){var n=l[1]|l[2]<<8|l[3]<<16;setTimeout(function(){r.controlTransfer("in",r.request.GETSTATUS,0,0,6,0,function(d){d[4]===r.state.dfuDNLOAD_IDLE?e(d):(console.log("Failed to execute address load"),typeof a>"u"||a?r.cleanup():e(d))})},n)}else console.log("Failed to request address load"),r.cleanup()})})};$.prototype.verify_flash=function(s,e){for(var a=0;a<s.length;a++)if(s[a]!==e[a])return console.log(`Verification failed on byte: ${a} expected: 0x${s[a].toString(16)} received: 0x${e[a].toString(16)}`),!1;return console.log(`Verification successful, matching: ${s.length} bytes`),!0};$.prototype.isBlockUsable=function(s,e){const a=this;let r=!1,l=s,n=e,d;do{d=!1;for(const _ of a.flash_layout.sectors){const E=_.start_address,T=_.num_pages*_.page_size,D=E+T-1;if(l>=E&&l<=D){if(l+n-1<=D){r=!0,d=!1;break}l=D+1,n-=T,d=!0;break}}}while(d);return r};$.prototype.upload_procedure=function(s){const e=this;switch(s){case 0:e.getChipInfo(0,function(x,U){if(U!==0||typeof x>"u")console.log(`Failed to detect chip info, resultCode: ${U}`),e.cleanup();else{let B;if(typeof x.internal_flash<"u"){if(B=1,e.chipInfo=x,e.flash_layout=x.internal_flash,f.firmware_flasher.parsed_hex.bytes_total>x.internal_flash.total_size){const I=f.firmware_flasher.parsed_hex.bytes_total,H=x.internal_flash.total_size,Y=f.firmware_flasher.bareBoard;console.log(`Firmware size ${I} exceeds board memory size ${H} (${Y})`)}}else typeof x.external_flash<"u"?(B=2,e.chipInfo=x,e.flash_layout=x.external_flash):(console.log("Failed to detect internal or external flash"),e.cleanup());if(typeof B<"u"){w(i.getMessage("dfu_device_flash_info",(e.flash_layout.total_size/1024).toString()));const I=[];for(const H of e.hex.data)e.isBlockUsable(H.address,H.bytes)||I.push(H);I.length>0?(w(i.getMessage("dfu_hex_address_errors")),f.firmware_flasher.flashingMessage(i.getMessage("dfu_hex_address_errors"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),e.leave()):e.getFunctionalDescriptor(0,function(H,Y){e.transferSize=Y?2048:H.wTransferSize,console.log(`Using transfer size: ${e.transferSize}`),e.clearStatus(function(){e.upload_procedure(B)})})}}});break;case 1:typeof e.chipInfo.option_bytes>"u"&&(console.log("Failed to detect option bytes"),e.cleanup());var a=function(){console.log("Initiate read unprotect");let x=i.getMessage("stm32ReadProtected");w(x),f.firmware_flasher.flashingMessage(x,f.firmware_flasher.FLASH_MESSAGE_TYPES.ACTION),e.controlTransfer("out",e.request.DNLOAD,0,0,0,[146],function(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(U){if(U[4]===e.state.dfuDNBUSY)var B=U[1]|U[2]<<8|U[3]<<16,I=B+2e4,H=0,Y=1e3,he=setInterval(function(){if(f.firmware_flasher.flashProgress(Math.min(H/I,1)*100),H<I){H+=Y;return}clearInterval(he),e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(oe,o){if(o){console.log("Unprotect memory command ran successfully. Unplug flight controller. Connect again in DFU mode and try flashing again."),w(i.getMessage("stm32UnprotectSuccessful"));let c=i.getMessage("stm32UnprotectUnplug");w(c),f.firmware_flasher.flashingMessage(c,f.firmware_flasher.FLASH_MESSAGE_TYPES.ACTION).flashProgress(0)}else console.log("Failed to execute unprotect memory command"),w(i.getMessage("stm32UnprotectFailed")),f.firmware_flasher.flashingMessage(i.getMessage("stm32UnprotectFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),console.log(oe),e.cleanup()},2e3)},Y);else{console.log("Failed to initiate unprotect memory command");let oe=i.getMessage("stm32UnprotectInitFailed");w(oe),f.firmware_flasher.flashingMessage(oe,f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),e.cleanup()}})})},r=function(){e.controlTransfer("in",e.request.UPLOAD,2,0,e.chipInfo.option_bytes.total_size,0,function(x,U){if(U){console.log("USB transfer error while reading option bytes: 1"),e.cleanup();return}e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(B){B[4]===e.state.dfuUPLOAD_IDLE&&x.length===e.chipInfo.option_bytes.total_size?(console.log("Option bytes read successfully"),console.log("Chip does not appear read protected"),w(i.getMessage("stm32NotReadProtected")),e.clearStatus(function(){e.upload_procedure(2)})):(console.log("Option bytes could not be read. Quite possibly read protected."),e.clearStatus(a))})})},l=function(x){if(x[4]===e.state.dfuERROR&&x[0]===e.status.errVENDOR){w(i.getMessage("stm32AddressLoadFailed")),e.clearStatus(a);return}else x[4]===e.state.dfuDNLOAD_IDLE?(console.log("Address load for option bytes sector succeeded."),e.clearStatus(r)):(w(i.getMessage("stm32AddressLoadUnknown")),e.cleanup())};e.clearStatus(function(){e.loadAddress(e.chipInfo.option_bytes.start_address,l,!1)});break;case 2:for(var n=[],d=0;d<e.flash_layout.sectors.length;d++)for(var _=0;_<e.flash_layout.sectors[d].num_pages;_++)if(e.options.erase_chip)n.push({sector:d,page:_});else for(var E=e.flash_layout.sectors[d].start_address+_*e.flash_layout.sectors[d].page_size,T=E+e.flash_layout.sectors[d].page_size-1,D=0;D<e.hex.data.length;D++){var V=e.hex.data[D].address>=E&&e.hex.data[D].address<=T,N=e.hex.data[D].address+e.hex.data[D].bytes-1,u=N>=E&&N<=T,v=e.hex.data[D].address<E&&N>T;if(V||u||v){var m=n.findIndex(function(x,U,B){return x.sector===d&&x.page===_});m===-1&&n.push({sector:d,page:_})}}if(n.length===0){console.log("Aborting, No flash pages to erase"),f.firmware_flasher.flashingMessage(i.getMessage("stm32InvalidHex"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),e.cleanup();break}f.firmware_flasher.flashingMessage(i.getMessage("stm32Erase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),console.log("Executing local chip erase",n);var F=0,g=0,b=function(){f.firmware_flasher.flashProgress((F+1)/n.length*100),F++,F===n.length?(console.log("Erase: complete"),w(i.getMessage("dfu_erased_kilobytes",(g/1024).toString())),e.upload_procedure(4)):S()},S=function(){var x=n[F].page*e.flash_layout.sectors[n[F].sector].page_size+e.flash_layout.sectors[n[F].sector].start_address,U=[65,x&255,x>>8&255,x>>16&255,x>>24&255];g+=e.flash_layout.sectors[n[F].sector].page_size,console.log(`Erasing. sector ${n[F].sector}, page ${n[F].page} @ 0x${x.toString(16)}`),e.controlTransfer("out",e.request.DNLOAD,0,0,0,U,function(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(B){if(B[4]===e.state.dfuDNBUSY){var I=B[1]|B[2]<<8|B[3]<<16;setTimeout(function(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(H){H[4]===e.state.dfuDNBUSY?(console.log("erase_page: dfuDNBUSY after timeout, clearing"),e.clearStatus(function(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(Y){Y[4]===e.state.dfuIDLE?b():(console.log(`Failed to erase page 0x${x.toString(16)} (did not reach dfuIDLE after clearing`),e.cleanup())})})):H[4]===e.state.dfuDNLOAD_IDLE?b():(console.log(`Failed to erase page 0x${x.toString(16)}`),e.cleanup())})},I)}else console.log(`Failed to initiate page erase, page 0x${x.toString(16)}`),e.cleanup()})})};S();break;case 4:console.log("Writing data ..."),f.firmware_flasher.flashingMessage(i.getMessage("stm32Flashing"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);var se=e.hex.data.length-1,y=0,K=e.hex.data[y].address,G=0,te=0,W=2,ce=function(){if(G<e.hex.data[y].bytes){var x=G+e.transferSize<=e.hex.data[y].bytes?e.transferSize:e.hex.data[y].bytes-G,U=e.hex.data[y].data.slice(G,G+x);K+=x,G+=x,te+=x,e.controlTransfer("out",e.request.DNLOAD,W++,0,0,U,function(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(B){if(B[4]===e.state.dfuDNBUSY){var I=B[1]|B[2]<<8|B[3]<<16;setTimeout(function(){e.controlTransfer("in",e.request.GETSTATUS,0,0,6,0,function(H){H[4]===e.state.dfuDNLOAD_IDLE?(f.firmware_flasher.flashProgress(te/(e.hex.bytes_total*2)*100),ce()):(console.log(`Failed to write ${x}bytes to 0x${K.toString(16)}`),e.cleanup())})},I)}else console.log(`Failed to initiate write ${x}bytes to 0x${K.toString(16)}`),e.cleanup()})})}else y<se?(y++,K=e.hex.data[y].address,G=0,W=2,e.loadAddress(K,ce)):(console.log("Writing: done"),e.upload_procedure(5))};e.loadAddress(K,ce);break;case 5:console.log("Verifying data ..."),f.firmware_flasher.flashingMessage(i.getMessage("stm32Verifying"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);for(var se=e.hex.data.length-1,ee=0,K=e.hex.data[ee].address,ie=0,ue=0,W=2,d=0;d<=se;d++)e.verify_hex.push([]);e.clearStatus(function(){e.loadAddress(K,function(){e.clearStatus(fe)})});var fe=function(){if(ie<e.hex.data[ee].bytes){var x=ie+e.transferSize<=e.hex.data[ee].bytes?e.transferSize:e.hex.data[ee].bytes-ie;e.controlTransfer("in",e.request.UPLOAD,W++,0,x,0,function(I,H){for(var Y=0;Y<I.length;Y++)e.verify_hex[ee].push(I[Y]);K+=x,ie+=x,ue+=x,f.firmware_flasher.flashProgress((e.hex.bytes_total+ue)/(e.hex.bytes_total*2)*100),fe()})}else if(ee<se)ee++,K=e.hex.data[ee].address,ie=0,W=2,e.clearStatus(function(){e.loadAddress(K,function(){e.clearStatus(fe)})});else{for(var U=!0,B=0;B<=se&&(U=e.verify_flash(e.hex.data[B].data,e.verify_hex[B]),!!U);B++);U?(console.log("Programming: SUCCESSFUL"),f.firmware_flasher.flashingMessage(i.getMessage("stm32ProgrammingSuccessful"),f.firmware_flasher.FLASH_MESSAGE_TYPES.VALID),e.leave()):(console.log("Programming: FAILED"),f.firmware_flasher.flashingMessage(i.getMessage("stm32ProgrammingFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),e.cleanup())}};break}};$.prototype.leave=function(){const s=this;let e;s.hex?e=s.hex.data[0].address:e=134217728,s.clearStatus(function(){s.loadAddress(e,function(){s.controlTransfer("out",s.request.DNLOAD,0,0,0,0,function(){s.controlTransfer("in",s.request.GETSTATUS,0,0,6,0,function(a){s.cleanup()})})})})};$.prototype.cleanup=function(){const s=this;s.releaseInterface(0),A.connect_lock=!1;const e=new Date().getTime()-s.upload_time_start;console.log(`Script finished after: ${e/1e3} seconds`),s.callback&&s.callback()};const me=new $,J=function(){this.baud=null,this.options={},this.callback=null,this.hex=null,this.verify_hex=[],this.receive_buffer=[],this.bytesToRead=0,this.read_callback=null,this.upload_time_start=0,this.upload_process_alive=!1,this.msp_connector=new Se,this.status={ACK:121,NACK:31},this.command={get:0,get_ver_r_protect_s:1,get_ID:2,read_memory:17,go:33,write_memory:49,erase:67,extended_erase:68,write_protect:99,write_unprotect:115,readout_protect:130,readout_unprotect:146},this.available_flash_size=0,this.page_size=0,this.useExtendedErase=!1};J.prototype.connect=function(s,e,a,r,l){const n=this;if(n.hex=a,n.port=s,n.baud=e,n.callback=l,n.options={no_reboot:!1,reboot_baud:!1,erase_chip:!1},r.no_reboot?n.options.no_reboot=!0:n.options.reboot_baud=r.reboot_baud,r.erase_chip&&(n.options.erase_chip=!0),n.options.no_reboot)P.connect(s,{bitrate:n.baud,parityBit:"even",stopBits:"one"},function(d){d?(A.connect_lock=!0,n.initialize()):w(i.getMessage("serialPortOpenFail"))});else{let d=0;const _=()=>{d!==0&&re.check_usb_devices(function(u){u?me.connect(_e,a,r):P.connect(n.port,{bitrate:n.baud,parityBit:"even",stopBits:"one"},function(v){v?n.initialize():(A.connect_lock=!1,w(i.getMessage("serialPortOpenFail")))})})},E=u=>{if(u){let v=function(){re.dfu_available?(console.log(`DFU available after ${m/10} seconds`),clearInterval(F),_()):(m++,m>100&&(clearInterval(F),console.log("failed to get DFU connection, gave up after 10 seconds"),w(i.getMessage("serialPortOpenFail")),A.connect_lock=!1))},m=0;const F=setInterval(v,100)}else A.connect_lock=!1},T=function(){P.connect(n.port,{bitrate:n.options.reboot_baud},function(u){if(!u){A.connect_lock=!1,w(i.getMessage("serialPortOpenFail"));return}console.log("Using legacy reboot method"),console.log('Sending ascii "R" to reboot');const v=new ArrayBuffer(1),m=new Uint8Array(v);m[0]=82,P.send(v,function(){P.disconnect(F=>E(F))})})},D=function(){w(i.getMessage("apiVersionReceived",[z.CONFIG.apiVersion])),ge.lt(z.CONFIG.apiVersion,Le)?n.msp_connector.disconnect(function(u){setTimeout(T,500)}):(console.log("Looking for capabilities via MSP"),O.send_message(Q.MSP_BOARD_INFO,!1,!1,()=>{Me(z.CONFIG.targetCapabilities,z.TARGET_CAPABILITIES_FLAGS.HAS_FLASH_BOOTLOADER)?(w(i.getMessage("deviceRebooting_flashBootloader")),console.log("flash bootloader detected"),d=4):(w(i.getMessage("deviceRebooting_romBootloader")),console.log("no flash bootloader detected"),d=1);const u=f.firmware_flasher.selectedBoard!=="0"?f.firmware_flasher.selectedBoard:"NONE",v=z.CONFIG.boardName?z.CONFIG.boardName:"UNKNOWN";function m(){const g=[];g.push8(d),setTimeout(()=>{O.send_message(Q.MSP_SET_REBOOT,g,()=>{n.msp_connector.disconnect(b=>E(b)),console.log("Reboot request received by device")})},100)}function F(){A.connect_lock=!1,d=0,console.log("User cancelled because selected target does not match verified board"),m(),f.firmware_flasher.refresh()}u!==v&&!f.firmware_flasher.localFirmwareLoaded?f.firmware_flasher.showDialogVerifyBoard(u,v,F,m):m()}))},V=function(){A.connect_lock=!1,console.log("Looking for capabilities via MSP failed"),f.firmware_flasher.flashingMessage(i.getMessage("stm32RebootingToBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID)},N=function(){A.connect_lock=!1,f.firmware_flasher.refresh()};A.connect_lock=!0,f.firmware_flasher.flashingMessage(i.getMessage("stm32RebootingToBootloader"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),n.msp_connector.connect(n.port,n.options.reboot_baud,D,V,N)}};J.prototype.initialize=function(){const s=this;s.receive_buffer=[],s.verify_hex=[],s.upload_time_start=new Date().getTime(),s.upload_process_alive=!1,f.firmware_flasher.flashingMessage(null,f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t('select[name="release"]').prop("disabled",!0),P.onReceive.addListener(function(e){s.read(e)}),A.interval_add("STM32_timeout",function(){s.upload_process_alive?s.upload_process_alive=!1:(console.log("STM32 - timed out, programming failed ..."),f.firmware_flasher.flashingMessage(i.getMessage("stm32TimedOut"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),A.interval_remove("STM32_timeout"),s.upload_procedure(99))},2e3),s.upload_procedure(1)};J.prototype.read=function(s){const e=new Uint8Array(s.data);for(const a of e)this.receive_buffer.push(a);if(this.receive_buffer.length>=this.bytesToRead&&this.bytesToRead!=0){const a=this.receive_buffer.slice(0,this.bytesToRead);this.receive_buffer.splice(0,this.bytesToRead),this.bytesToRead=0,this.read_callback(a)}};J.prototype.retrieve=function(s,e){if(this.receive_buffer.length>=s){const a=this.receive_buffer.slice(0,s);this.receive_buffer.splice(0,s),e(a)}else this.bytesToRead=s,this.read_callback=e};J.prototype.send=function(s,e,a){this.upload_process_alive=!0;const r=new ArrayBuffer(s.length);new Uint8Array(r).set(s),this.bytesToRead=e,this.read_callback=a,this.receive_buffer=[],P.send(r)};J.prototype.verify_response=function(s,e){if(s!==e[0]){const a=`STM32 Communication failed, wrong response, expected: ${s} (0x${s.toString(16)}) received: ${e[0]} (0x${e[0].toString(16)})`;return console.error(a),f.firmware_flasher.flashingMessage(i.getMessage("stm32WrongResponse",[s,s.toString(16),e[0],e[0].toString(16)]),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),this.upload_procedure(99),!1}return!0};J.prototype.verify_chip_signature=function(s){switch(s){case 1042:console.log("Chip recognized as F1 Low-density");break;case 1040:console.log("Chip recognized as F1 Medium-density"),this.available_flash_size=131072,this.page_size=1024;break;case 1044:this.available_flash_size=262144,this.page_size=2048,console.log("Chip recognized as F1 High-density");break;case 1048:console.log("Chip recognized as F1 Connectivity line");break;case 1056:console.log("Chip recognized as F1 Medium-density value line");break;case 1064:console.log("Chip recognized as F1 High-density value line");break;case 1072:console.log("Chip recognized as F1 XL-density value line");break;case 1046:console.log("Chip recognized as L1 Medium-density ultralow power");break;case 1078:console.log("Chip recognized as L1 High-density ultralow power");break;case 1063:console.log("Chip recognized as L1 Medium-density plus ultralow power");break;case 1041:console.log("Chip recognized as F2 STM32F2xxxx");break;case 1088:console.log("Chip recognized as F0 STM32F051xx");break;case 1092:console.log("Chip recognized as F0 STM32F050xx");break;case 1043:console.log("Chip recognized as F4 STM32F40xxx/41xxx");break;case 1049:console.log("Chip recognized as F4 STM32F427xx/437xx, STM32F429xx/439xx");break;case 1074:console.log("Chip recognized as F3 STM32F37xxx, STM32F38xxx");break;case 1058:console.log("Chip recognized as F3 STM32F30xxx, STM32F31xxx"),this.available_flash_size=262144,this.page_size=2048;break}return this.available_flash_size>0?this.hex.bytes_total<this.available_flash_size?!0:(console.log(`Supplied hex is bigger then flash available on the chip, HEX: ${this.hex.bytes_total} bytes, limit = ${this.available_flash_size} bytes`),!1):(console.log(`Chip NOT recognized: ${s}`),!1)};J.prototype.verify_flash=function(s,e){for(let a=0;a<s.length;a++)if(s[a]!==e[a])return console.log(`Verification failed on byte: ${a} expected: 0x${s[a].toString(16)} received: 0x${e[a].toString(16)}`),!1;return console.log(`Verification successful, matching: ${s.length} bytes`),!0};J.prototype.upload_procedure=function(s){const e=this;switch(s){case 1:f.firmware_flasher.flashingMessage(i.getMessage("stm32ContactingBootloader"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let a=0;A.interval_add("stm32_initialize_mcu",function(){e.send([127],1,function(u){u[0]===127||u[0]===e.status.ACK||u[0]===e.status.NACK?(A.interval_remove("stm32_initialize_mcu"),console.log("STM32 - Serial interface initialized on the MCU side"),e.upload_procedure(2)):(f.firmware_flasher.flashingMessage(i.getMessage("stm32ContactingBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),A.interval_remove("stm32_initialize_mcu"),e.upload_procedure(99))}),a++>3&&(console.log("STM32 - no response from bootloader, disconnecting"),f.firmware_flasher.flashingMessage(i.getMessage("stm32ResponseBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),A.interval_remove("stm32_initialize_mcu"),A.interval_remove("STM32_timeout"),e.upload_procedure(99))},250,!0);break;case 2:e.send([e.command.get,255],2,function(u){e.verify_response(e.status.ACK,u)&&e.retrieve(u[1]+1+1,function(v){console.log(`STM32 - Bootloader version: ${(parseInt(v[0].toString(16))/10).toFixed(1)}`),e.useExtendedErase=v[7]===e.command.extended_erase,e.upload_procedure(3)})});break;case 3:e.send([e.command.get_ID,253],2,function(u){e.verify_response(e.status.ACK,u)&&e.retrieve(u[1]+1+1,function(v){const m=v[0]<<8|v[1];console.log(`STM32 - Signature: 0x${m.toString(16)}`),e.verify_chip_signature(m)?e.upload_procedure(4):e.upload_procedure(99)})});break;case 4:if(e.useExtendedErase){e.options.erase_chip?(console.log("Executing global chip erase (via extended erase)"),f.firmware_flasher.flashingMessage(i.getMessage("stm32GlobalEraseExtended"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),e.send([e.command.extended_erase,187],1,function(v){e.verify_response(e.status.ACK,v)&&e.send([255,255,0],1,function(m){e.verify_response(e.status.ACK,m)&&(console.log("Executing global chip extended erase: done"),e.upload_procedure(5))})})):(console.log("Executing local erase (via extended erase)"),f.firmware_flasher.flashingMessage(i.getMessage("stm32LocalEraseExtended"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),e.send([e.command.extended_erase,187],1,function(v){if(e.verify_response(e.status.ACK,v)){const m=e.hex.data[e.hex.data.length-1].address+e.hex.data[e.hex.data.length-1].bytes-134217728,F=Math.ceil(m/e.page_size),g=[];let b=0,S;S=F-1>>8,g.push(S),b^=S,S=F-1&255,g.push(S),b^=S;for(let y=0;y<F;y++)S=y>>8,g.push(S),b^=S,S=y&255,g.push(S),b^=S;g.push(b),console.log(`Erasing. pages: 0x00 - 0x${F.toString(16)}, checksum: 0x${b.toString(16)}`),e.send(g,1,function(y){e.verify_response(e.status.ACK,y)&&(console.log("Erasing: done"),e.upload_procedure(5))})}}));break}e.options.erase_chip?(console.log("Executing global chip erase"),f.firmware_flasher.flashingMessage(i.getMessage("stm32GlobalErase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),e.send([e.command.erase,188],1,function(v){e.verify_response(e.status.ACK,v)&&e.send([255,0],1,function(m){e.verify_response(e.status.ACK,m)&&(console.log("Erasing: done"),e.upload_procedure(5))})})):(console.log("Executing local erase"),f.firmware_flasher.flashingMessage(i.getMessage("stm32LocalErase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),e.send([e.command.erase,188],1,function(v){if(e.verify_response(e.status.ACK,v)){const m=e.hex.data[e.hex.data.length-1].address+e.hex.data[e.hex.data.length-1].bytes-134217728,F=Math.ceil(m/e.page_size),g=[];let b=F-1;g.push(F-1);for(let S=0;S<F;S++)g.push(S),b^=S;g.push(b),e.send(g,1,function(S){e.verify_response(e.status.ACK,S)&&(console.log("Erasing: done"),e.upload_procedure(5))})}}));break;case 5:console.log("Writing data ..."),f.firmware_flasher.flashingMessage(i.getMessage("stm32Flashing"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let r=e.hex.data.length-1,l=0,n=e.hex.data[l].address,d=0,_=0;const E=function(){if(d<e.hex.data[l].bytes){const u=d+256<=e.hex.data[l].bytes?256:e.hex.data[l].bytes-d;e.send([e.command.write_memory,206],1,function(v){if(e.verify_response(e.status.ACK,v)){const m=[n>>24,n>>16,n>>8,n],F=m[0]^m[1]^m[2]^m[3];e.send([m[0],m[1],m[2],m[3],F],1,function(g){if(e.verify_response(e.status.ACK,g)){const b=Array.from(u+2);b[0]=u-1;let S=b[0];for(let y=0;y<u;y++)b[y+1]=e.hex.data[l].data[d],S^=e.hex.data[l].data[d],d++;b[b.length-1]=S,n+=u,_+=u,e.send(b,1,function(y){e.verify_response(e.status.ACK,y)&&E()}),f.firmware_flasher.flashProgress(Math.round(_/(e.hex.bytes_total*2)*100))}})}})}else l<r?(l++,n=e.hex.data[l].address,d=0,E()):(console.log("Writing: done"),e.upload_procedure(6))};E();break;case 6:console.log("Verifying data ..."),f.firmware_flasher.flashingMessage(i.getMessage("stm32Verifying"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),r=e.hex.data.length-1;let T=0;n=e.hex.data[T].address;let D=0,V=0;for(let u=0;u<=r;u++)e.verify_hex.push([]);const N=function(){if(D<e.hex.data[T].bytes){const u=D+256<=e.hex.data[T].bytes?256:e.hex.data[T].bytes-D;e.send([e.command.read_memory,238],1,function(v){if(e.verify_response(e.status.ACK,v)){const m=[n>>24,n>>16,n>>8,n],F=m[0]^m[1]^m[2]^m[3];e.send([m[0],m[1],m[2],m[3],F],1,function(g){if(e.verify_response(e.status.ACK,g)){const b=u-1;e.send([b,~b&255],1,function(S){e.verify_response(e.status.ACK,S)&&e.retrieve(u,function(y){for(const G of y)e.verify_hex[T].push(G);n+=u,D+=u,V+=u,N()})}),f.firmware_flasher.flashProgress(Math.round((e.hex.bytes_total+V)/(e.hex.bytes_total*2)*100))}})}})}else if(T<r)T++,n=e.hex.data[T].address,D=0,N();else{let u=!0;for(let v=0;v<=r&&(u=e.verify_flash(e.hex.data[v].data,e.verify_hex[v]),!!u);v++);u?(console.log("Programming: SUCCESSFUL"),f.firmware_flasher.flashingMessage(i.getMessage("stm32ProgrammingSuccessful"),f.firmware_flasher.FLASH_MESSAGE_TYPES.VALID),e.upload_procedure(7)):(console.log("Programming: FAILED"),f.firmware_flasher.flashingMessage(i.getMessage("stm32ProgrammingFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),e.upload_procedure(99))}};N();break;case 7:console.log("Sending GO command: 0x8000000"),e.send([e.command.go,222],1,function(u){if(e.verify_response(e.status.ACK,u)){n=[8,2048,524288,134217728];const m=n[0]^n[1]^n[2]^n[3];e.send([n[0],n[1],n[2],n[3],m],1,function(F){e.verify_response(e.status.ACK,F)&&e.upload_procedure(99)})}});break;case 99:A.interval_remove("STM32_timeout"),P.connectionId?P.disconnect(e.cleanup):e.cleanup();break}};J.prototype.cleanup=function(){ye.reset(),A.connect_lock=!1,t('select[name="release"]').prop("disabled",!1);const s=new Date().getTime()-self.upload_time_start;console.log(`Script finished after: ${s/1e3} seconds`),self.callback&&self.callback()};const He=new J,q={targets:null,releaseLoader:new Ce,localFirmwareLoaded:!1,selectedBoard:void 0,boardNeedsVerification:!1,allowBoardDetection:!0,isFirstRun:!0,isFlashing:!1,intel_hex:void 0,parsed_hex:void 0,isConfigLocal:!1,configFilename:null,config:{},developmentFirmwareLoaded:!1};q.initialize=function(s){const e=this;A.active_tab!=="firmware_flasher"&&(A.active_tab="firmware_flasher"),e.selectedBoard=void 0,e.localFirmwareLoaded=!1,e.isConfigLocal=!1,e.intel_hex=void 0,e.parsed_hex=void 0;function a(){function r(){navigator.onLine&&e.releaseLoader.loadSponsorTile(De.enabled?"dark":"light",o=>{o?(t("div.tab_sponsor").html(o),t("div.tab_sponsor").hide()):t("div.tab_sponsor").hide()})}function l(){return z.CONFIG.buildKey.length===32}function n(o,c){const h=new Worker("./js/workers/hex_parser.js");h.onmessage=function(p){c(p.data)},h.postMessage(o)}function d(o){e.localFirmwareLoaded?e.flashingMessage(i.getMessage("firmwareFlasherFirmwareLocalLoaded",{filename:o,bytes:e.parsed_hex.bytes_total}),e.FLASH_MESSAGE_TYPES.NEUTRAL):e.flashingMessage('<a class="save_firmware"  title="Save Firmware"></a>',e.FLASH_MESSAGE_TYPES.NEUTRAL),e.enableFlashButton(!0)}function _(o){o.manufacturer?(t("div.release_info #manufacturer").text(o.manufacturer),t("div.release_info #manufacturerInfo").show()):t("div.release_info #manufacturerInfo").hide(),t("div.release_info .target").text(o.target),t("div.release_info .name").text(o.release).prop("href",o.releaseUrl),t("div.release_info .date").text(o.date),t("div.release_info #targetMCU").text(o.mcu),t("div.release_info .configFilename").text(e.isConfigLocal?e.configFilename:"[default]");let c="https://betaflight.com/docs/wiki/boards/missing";const h=`https://betaflight.com/docs/wiki/boards/${o.target}`;Ie(h)&&(c=h);const p=t("#targetWikiInfoUrl");p.html("&nbsp;&nbsp;&nbsp;[Wiki]"),p.attr("href",c),o.cloudBuild?(t("div.release_info #cloudTargetInfo").show(),t("div.release_info #cloudTargetLog").text(""),t("div.release_info #cloudTargetStatus").text("pending")):t("div.release_info #cloudTargetInfo").hide(),e.targets&&(t("div.release_info").slideDown(),t(".tab-firmware_flasher .content_wrapper").animate({scrollTop:t("div.release_info").position().top},1e3))}function E(){e.config={},e.isConfigLocal=!1,e.configFilename=null}function T(o,c){e.config=o.join(`
`),e.isConfigLocal=c!==void 0,e.configFilename=c!==void 0?c:null}function D(o,c){e.intel_hex=o,n(e.intel_hex,function(h){e.parsed_hex=h,e.parsed_hex?(R.setFirmwareData(R.DATA.FIRMWARE_SIZE,e.parsed_hex.bytes_total),d(c)):(e.flashingMessage(i.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),e.enableFlashButton(!1))})}function V(o,c){e.localFirmwareLoaded=!1,D(o,c),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(i.getMessage("firmwareFlasherButtonLoadOnline"))}function N(o){if(!o||!navigator.onLine){t('select[name="board"]').empty().append('<option value="0">Offline</option>'),t('select[name="firmware_version"]').empty().append('<option value="0">Offline</option>');return}const c=t('select[name="board"]');c.empty(),c.append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLabelSelectBoard")}</option>`));const h=t('select[name="firmware_version"]');h.empty(),h.append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`)),Object.keys(o).sort((p,C)=>p.target-C.target).forEach(function(p,C){const L=o[p],k=t(`<option value='${L.target}'>${L.target}</option>`);c.append(k)}),f.firmware_flasher.targets=o,t("div.build_configuration").slideUp()}function u(o,c){o.empty(),c.forEach(h=>{h.default?o.append(t(`<option value='${h.value}' selected>${h.name}</option>`)):o.append(t(`<option value='${h.value}'>${h.name}</option>`))})}function v(o){navigator.onLine&&(u(t('select[name="radioProtocols"]'),o.radioProtocols),u(t('select[name="telemetryProtocols"]'),o.telemetryProtocols),u(t('select[name="options"]'),o.generalOptions),u(t('select[name="motorProtocols"]'),o.motorProtocols),l()||m())}function m(){const o=ae("ffRadioProtocol").ffRadioProtocol;o&&t('select[name="radioProtocols"] option').filter(function(h,p){return p.value===o}).length!==0&&t('select[name="radioProtocols"]').val(o)}let F;const g=t('select[name="build_type"]');function b(){g.empty(),F.forEach(({tag:o,title:c},h)=>{g.append(t(`<option value='${h}'>${o?i.getMessage(o):c}</option>`))})}const S=[{tag:"firmwareFlasherOptionLabelBuildTypeRelease"},{tag:"firmwareFlasherOptionLabelBuildTypeReleaseCandidate"},{tag:"firmwareFlasherOptionLabelBuildTypeDevelopment"}];function y(){t(this).is(":checked")?t("tr.build_type").show():(t("tr.build_type").hide(),g.val(0).trigger("change"))}function G(){const o=t(this).is(":checked");o?F=S:F=S.slice(0,2),b(),g.val(0).trigger("change"),setTimeout(()=>{t("tr.expertOptions").toggle(o),t("div.expertOptions").toggle(o)},0),ne({expertMode:o})}const te=t(".tab-firmware_flasher input.expert_mode"),ce=ae("expertMode").expertMode;te.prop("checked",ce),te.on("change",G).trigger("change"),t("input.show_development_releases").change(y).change(),i.localizePage(),r(),g.on("change",function(){e.enableLoadRemoteFileButton(!1),R.setFirmwareData(R.DATA.FIRMWARE_CHANNEL,t("option:selected",this).text());const o=g.val();if(t('select[name="board"]').empty().append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLoading")}</option>`)),t('select[name="firmware_version"]').empty().append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLoading")}</option>`)),!A.connect_lock)try{e.releaseLoader.loadTargets(N)}catch(c){console.error(c)}ne({selected_build_type:o})});function se(o){t("div.build_configuration").slideUp(),t("div.release_info").slideUp(),e.localFirmwareLoaded||(e.enableFlashButton(!1),e.flashingMessage(i.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),e.parsed_hex&&e.parsed_hex.bytes_total&&(console.log("throw out loaded hex"),e.intel_hex=void 0,e.parsed_hex=void 0));const c=t('select[name="board"] option:selected').val();function h(p){if(e.targetDetail=p,p.cloudBuild===!0){t("div.build_configuration").slideDown();const C=te.is(":checked");C&&(p.releaseType==="Unstable"?(e.releaseLoader.loadCommits(p.release,L=>{const k=t('select[name="commits"]');k.empty(),L.forEach(X=>{k.append(t(`<option value='${X.sha}'>${X.message}</option>`))})}),t("div.commitSelection").show()):t("div.commitSelection").hide()),t("div.expertOptions").toggle(C)}p.configuration&&!e.isConfigLocal&&T(p.configuration),e.enableLoadRemoteFileButton(!0)}e.releaseLoader.loadTarget(c,o,h),l()&&navigator.onLine?e.releaseLoader.loadOptionsByBuildKey(o,z.CONFIG.buildKey,v):e.releaseLoader.loadOptions(o,v)}function ee(o,c){const h=function(C,L){return-ge.compareBuild(C.release,L.release)};o.empty();const p=c.releases;if(p.length>0){o.append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersionFor")} ${c.target}</option>`));const C=t('select[name="build_type"]').val();p.sort(h).filter(L=>L.type==="Unstable"&&C>1||L.type==="ReleaseCandidate"&&C>0||L.type==="Stable").forEach(function(L){const k=L.release,X=t(`<option value='${k}'>${k} [${L.label}]</option>`),M=`${c}/${L}`;X.data("summary",M),o.append(X)}),o.prop("selectedIndex",1),se(o.val())}}function K(){E(),e.intel_hex=void 0,e.parsed_hex=void 0,e.localFirmwareLoaded=!1}t('select[name="board"]').select2(),t('select[name="radioProtocols"]').select2(),t('select[name="telemetryProtocols"]').select2(),t('select[name="motorProtocols"]').select2(),t('select[name="options"]').select2({tags:!1,closeOnSelect:!1}),t('select[name="commits"]').select2({tags:!0}),t('select[name="options"]').on("select2:opening",function(){t(this).parent().find(".select2-search__field").prop("disabled",!1)}).on("select2:closing",function(){t(this).parent().find(".select2-search__field").prop("disabled",!0)}),t('select[name="radioProtocols"]').on("select2:select",function(){const o=t('select[name="radioProtocols"] option:selected').first().val();o&&ne({ffRadioProtocol:o})}),t('select[name="board"]').on("change",function(){e.enableLoadRemoteFileButton(!1);let o=t(this).val();if(o===null&&(o="0",t(this).val(o).trigger("change")),!A.connect_lock){e.selectedBoard=o,console.log("board changed to",o),e.flashingMessage(i.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t("div.release_info").slideUp(),t("div.build_configuration").slideUp(),e.localFirmwareLoaded||e.enableFlashButton(!1);const c=t('select[name="firmware_version"]');o==="0"?(K(),c.empty(),c.append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`))):(c.empty(),c.append(t(`<option value='0'>${i.getMessage("firmwareFlasherOptionLoading")}</option>`)),e.releaseLoader.loadTargetReleases(o,h=>ee(c,h)))}});const ie=['select[name="board"]','select[name="radioProtocols"]','select[name="telemetryProtocols"]','select[name="motorProtocols"]','select[name="options"]','select[name="commits"]'];t(document).on("select2:open",ie.join(","),()=>{const o=document.querySelectorAll(".select2-container--open .select2-search__field");t(this).one("mouseup keyup",()=>{setTimeout(()=>{o[o.length-1].focus()},0)})});function ue(o){let c=[],h=!1;for(let p=0;p<o.length;p++){if((o.charAt(p)===`
`||o.charAt(p)==="\r")&&(h=!1),o.charAt(p)==="#"&&(h=!0),!h&&o.charCodeAt(p)>255)return e.flashingMessage(i.getMessage("firmwareFlasherConfigCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),w(i.getMessage("firmwareFlasherConfigCorruptedLogMessage")),null;o.charCodeAt(p)>255?c.push("_"):c.push(o.charAt(p))}return c.join("").split(`
`)}const W=t("div#port-picker #port");function fe(o){const c={};let h=!1;if((t("input.erase_chip").is(":checked")||te.is(":not(:checked)"))&&(c.erase_chip=!0,h=!0),R.setFirmwareData(R.DATA.FIRMWARE_ERASE_ALL,h.toString()),t("option:selected",W).data().isDFU)R.sendEvent(R.EVENT_CATEGORIES.FLASHING,"Flashing",e.fileName||null),me.connect(_e,o,c);else if(String(W.val())!=="0"){const p=String(W.val());t("input.updating").is(":checked")?c.no_reboot=!0:c.reboot_baud=parseInt(t("div#port-picker #baud").val());let C=115200;t("input.flash_manual_baud").is(":checked")&&(C=parseInt(t("#flash_manual_baud_rate").val())),R.sendEvent(R.EVENT_CATEGORIES.FLASHING,"Flashing",e.fileName||null),He.connect(p,C,o,c)}else console.log("Please select valid serial port"),w(i.getMessage("firmwareFlasherNoValidPort"));e.isFlashing=!1}function x(){if(!t("option:selected",W).data().isDFU){let c=function(){O.clearListeners(),O.disconnect_cleanup()},h=function(M){M||w(i.getMessage("firmwareFlasherBoardVerificationFail")),P.disconnect(c)},p=function(){const M=z.CONFIG.boardName,j=t('select[name="board"]'),le=t('select[name="board"] option'),pe=j.val();let de=!1;M?(le.each((Ve,Te)=>{t(Te).text()===M&&(de=!0)}),M!==pe&&j.val(M).trigger("change"),w(i.getMessage(de?"firmwareFlasherBoardVerificationSuccess":"firmwareFlasherBoardVerficationTargetNotAvailable",{boardName:M})),h(!0)):h(!1)},C=function(){O.send_message(Q.MSP_BOARD_INFO,!1,!1,p)},L=function(){if(ge.gte(z.CONFIG.apiVersion,Ne)&&navigator.onLine&&z.CONFIG.flightControllerIdentifier==="BTFL"){let M=function(j){z.CONFIG.buildOptions=j.Request.Options,C()};O.send_message(Q.MSP2_GET_TEXT,o.crunch(Q.MSP2_GET_TEXT,Q.BUILD_KEY),!1,()=>{O.send_message(Q.MSP2_GET_TEXT,o.crunch(Q.MSP2_GET_TEXT,Q.CRAFT_NAME),!1,()=>{l()?e.releaseLoader.requestBuildOptions(z.CONFIG.buildKey,M,C):C()})})}else C()},k=function(){console.log("Requesting board information"),O.send_message(Q.MSP_API_VERSION,!1,!1,()=>{w(i.getMessage("apiVersionReceived",z.CONFIG.apiVersion)),z.CONFIG.apiVersion.includes("null")||ge.lt(z.CONFIG.apiVersion,Be)?h(!1):O.send_message(Q.MSP_FC_VARIANT,!1,!1,L)})},X=function(M){M?(P.onReceive.addListener(j=>O.read(j)),o=new be,O.listen(o.process_data.bind(o)),k()):w(i.getMessage("serialPortOpenFail"))},o;if(String(W.val())!=="0"){const M=String(W.val());let j=115200;t("input.flash_manual_baud").is(":checked")&&(j=parseInt(t("#flash_manual_baud_rate").val())),w(i.getMessage("firmwareFlasherDetectBoardQuery")),(e.targets?Object.keys(e.targets).length>0:!1)?P.connected||P.connectionId?console.warn("Attempting to connect while there still is a connection",P.connected,P.connectionId,P.openCanceled):P.connect(M,{bitrate:j},X):console.log("Releases not loaded yet")}else w(i.getMessage("firmwareFlasherNoValidPort"))}}const U=t("a.detect-board");U.on("click",()=>{U.addClass("disabled"),x(),setTimeout(()=>U.removeClass("disabled"),1e3)});function B(){const o=re.dfu_available,c=A.connect_lock,h=re.port_available||e.isFirstRun,p=o||c||!h;U.toggleClass("disabled",p),e.isFirstRun=!1}let I=ae("erase_chip");I.erase_chip?t("input.erase_chip").prop("checked",!0):t("input.erase_chip").prop("checked",!1),t("input.erase_chip").change(function(){ne({erase_chip:t(this).is(":checked")})}).change(),I=ae("show_development_releases"),t("input.show_development_releases").prop("checked",I.show_development_releases).change(function(){ne({show_development_releases:t(this).is(":checked")})}).change(),I=ae("selected_build_type"),g.val(I.selected_build_type||0).trigger("change"),I=ae("no_reboot_sequence"),I.no_reboot_sequence?(t("input.updating").prop("checked",!0),t(".flash_on_connect_wrapper").show()):t("input.updating").prop("checked",!1),t("input.updating").change(function(){const o=t(this).is(":checked");o?t(".flash_on_connect_wrapper").show():(t("input.flash_on_connect").prop("checked",!1).change(),t(".flash_on_connect_wrapper").hide()),ne({no_reboot_sequence:o})}),t("input.updating").change(),I=ae("flash_manual_baud"),I.flash_manual_baud?t("input.flash_manual_baud").prop("checked",!0):t("input.flash_manual_baud").prop("checked",!1),t("input.corebuild_mode").change(function(){const o=t(this).is(":checked");t(".hide-in-core-build-mode").toggle(!o),t("div.expertOptions").toggle(!o&&te.is(":checked"))}),t("input.corebuild_mode").change(),t("input.flash_manual_baud").change(function(){const o=t(this).is(":checked");ne({flash_manual_baud:o})}),t("input.flash_manual_baud").change(),I=ae("flash_manual_baud_rate"),t("#flash_manual_baud_rate").val(I.flash_manual_baud_rate),t("#flash_manual_baud_rate").change(function(){const o=parseInt(t("#flash_manual_baud_rate").val());ne({flash_manual_baud_rate:o})}),t("input.flash_manual_baud_rate").change(),t("a.load_file").on("click",function(){e.enableFlashButton(!1),e.developmentFirmwareLoaded=!1,R.setFirmwareData(R.DATA.FIRMWARE_CHANNEL,void 0),R.setFirmwareData(R.DATA.FIRMWARE_SOURCE,"file"),chrome.fileSystem.chooseEntry({type:"openFile",accepts:[{description:"target files",extensions:["hex","config"]}]},function(o){Z()||(t("div.build_configuration").slideUp(),chrome.fileSystem.getDisplayPath(o,function(c){console.log("Loading file from:",c),o.file(function(h){R.setFirmwareData(R.DATA.FIRMWARE_NAME,h.name);const p=new FileReader;p.onloadend=function(C){if(C.total!==0&&C.total===C.loaded)if(console.log(`File loaded (${C.loaded})`),h.name.split(".").pop()==="hex")e.intel_hex=C.target.result,n(e.intel_hex,function(L){e.parsed_hex=L,e.parsed_hex?(R.setFirmwareData(R.DATA.FIRMWARE_SIZE,e.parsed_hex.bytes_total),e.localFirmwareLoaded=!0,d(h.name)):e.flashingMessage(i.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID)});else{K();let L=ue(C.target.result);L!==null&&(T(L,h.name),e.isConfigLocal&&!e.parsed_hex&&e.flashingMessage(i.getMessage("firmwareFlasherLoadedConfig"),e.FLASH_MESSAGE_TYPES.NEUTRAL),(e.isConfigLocal&&e.parsed_hex&&!e.localFirmwareLoaded||e.localFirmwareLoaded)&&(e.enableFlashButton(!0),e.flashingMessage(i.getMessage("firmwareFlasherFirmwareLocalLoaded",e.parsed_hex.bytes_total),e.FLASH_MESSAGE_TYPES.NEUTRAL)))}},p.readAsText(h)})}))})}),t('select[name="firmware_version"]').change(o=>{se(t("option:selected",o.target).val())}),t("a.load_remote_file").on("click",function(o){if(!e.selectedBoard)return;if(e.enableLoadRemoteFileButton(!1),e.localFirmwareLoaded=!1,e.developmentFirmwareLoaded=F[t('select[name="build_type"]').val()].tag==="firmwareFlasherOptionLabelBuildTypeDevelopment",R.setFirmwareData(R.DATA.FIRMWARE_SOURCE,"http"),t('select[name="firmware_version"]').val()==="0"){w(i.getMessage("firmwareFlasherNoFirmwareSelected"));return}function c(){t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(i.getMessage("firmwareFlasherButtonLoadOnline")),i.localizePage()}function h(L,k,X,M){M===!0&&t("div.release_info #cloudTargetLog").text(i.getMessage("firmwareFlasherCloudBuildLogUrl")).prop("href",`https://build.betaflight.com/api/builds/${k}/log`),t("div.release_info #cloudTargetStatus").text(i.getMessage(`firmwareFlasherCloudBuild${L}`)),t(".buildProgress").val(X)}function p(L,k,X){k.status==="success"?(h(X<=0?"SuccessCached":"Success",L.key,100,!0),k.configuration!==void 0&&!e.isConfigLocal&&T(k.configuration),e.releaseLoader.loadTargetHex(L.url,M=>V(M,L.file),c)):(h(X>10?"TimedOut":"Failed",L.key,0,!0),c())}function C(L){let k={target:L.target,release:L.release,options:[]};(L.cloudBuild!==!0||t('input[name="coreBuildModeCheckbox"]').is(":checked"))===!0?k.options.push("CORE_BUILD"):(k.options.push("CLOUD_BUILD"),t('select[name="radioProtocols"] option:selected').each(function(){k.options.push(t(this).val())}),t('select[name="telemetryProtocols"] option:selected').each(function(){k.options.push(t(this).val())}),t('select[name="options"] option:selected').each(function(){k.options.push(t(this).val())}),t('select[name="motorProtocols"] option:selected').each(function(){k.options.push(t(this).val())}),t('input[name="expertModeCheckbox"]').is(":checked")&&(L.releaseType==="Unstable"&&(k.commit=t('select[name="commits"] option:selected').val()),t('input[name="customDefines"]').val().split(" ").map(M=>M.trim()).forEach(M=>{k.options.push(M)}))),console.info("Build request:",k),e.releaseLoader.requestBuild(k,M=>{if(console.info("Build response:",M),e.targetDetail.file=M.file,!L.cloudBuild){e.releaseLoader.loadTargetHex(M.url,le=>V(le,M.file),c);return}R.setFirmwareData(R.DATA.FIRMWARE_NAME,M.file),h("Pending",M.key,0,!1);let j=1;e.releaseLoader.requestBuildStatus(M.key,le=>{if(le.status!=="queued"){p(M,le,0);return}const pe=setInterval(()=>{e.releaseLoader.requestBuildStatus(M.key,de=>{if(de.status!=="queued"||j>10){clearInterval(pe),p(M,de,j);return}h("Processing",M.key,j*10,!1),j++})},5e3)})},c)}e.targetDetail?(t("a.load_remote_file").text(i.getMessage("firmwareFlasherButtonDownloading")),e.enableLoadRemoteFileButton(!1),_(e.targetDetail),C(e.targetDetail)):(t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),i.localizePage())}),t("a.exit_dfu").on("click",function(){if(e.enableDfuExitButton(!1),!A.connect_lock){R.sendEvent(R.EVENT_CATEGORIES.FLASHING,"ExitDfu",null);try{console.log("Closing DFU"),me.connect(_e,e.parsed_hex,{exitDfu:!0})}catch(o){console.log(`Exiting DFU failed: ${o.message}`)}}}),W.on("change",function(){A.active_tab==="firmware_flasher"&&(A.connect_lock||(t("option:selected",this).data().isDFU?e.enableDfuExitButton(!0):(e.isFlashing||(e.boardNeedsVerification&&(e.boardNeedsVerification=!1,x()),e.selectedBoard&&(e.enableLoadRemoteFileButton(!0),e.enableLoadFileButton(!0))),e.enableDfuExitButton(!1))),B())}).trigger("change"),t("a.flash_firmware").on("click",function(){e.isFlashing=!0,e.enableFlashButton(!1),e.enableDfuExitButton(!1),e.enableLoadRemoteFileButton(!1),e.enableLoadFileButton(!1);function o(){e.developmentFirmwareLoaded?Y():oe()}t("option:selected",W).data().isDFU?o():A.showYesNoDialog({title:i.getMessage("firmwareFlasherRemindBackupTitle"),text:i.getMessage("firmwareFlasherRemindBackup"),buttonYesText:i.getMessage("firmwareFlasherBackup"),buttonNoText:i.getMessage("firmwareFlasherBackupIgnore"),buttonYesCallback:()=>q.backupConfig(o),buttonNoCallback:o})});function Y(){const c="lastDevelopmentWarningTimestamp";function h(){const p={};p[c]=Date.now(),Re(p)}I=ke(c),!I[c]||Date.now()-I[c]>864e5?he(h):oe()}function he(o){const c=t("#dialogUnstableFirmwareAcknowledgement")[0],h=t("#dialogUnstableFirmwareAcknowledgement-flashbtn"),p=t('input[name="dialogUnstableFirmwareAcknowledgement-acknowledge"]');p.change(function(){t(this).is(":checked")?h.removeClass("disabled"):h.addClass("disabled")}),h.click(function(){c.close(),p.is(":checked")&&(o&&o(),oe())}),t("#dialogUnstableFirmwareAcknowledgement-cancelbtn").click(function(){c.close()}),c.addEventListener("close",function(){p.prop("checked",!1).change()}),c.showModal()}function oe(){if(!A.connect_lock)if(e.parsed_hex)try{e.config&&!e.parsed_hex.configInserted&&(new Ge().insertConfig(e.parsed_hex,e.config)?e.parsed_hex.configInserted=!0:(console.log("Firmware does not support custom defaults."),E())),fe(e.parsed_hex)}catch(o){console.log(`Flashing failed: ${o.message}`)}else t("span.progressLabel").attr("i18n","firmwareFlasherFirmwareNotLoaded").removeClass("i18n-replaced"),i.localizePage()}t("span.progressLabel").on("click","a.save_firmware",function(){chrome.fileSystem.chooseEntry({type:"saveFile",suggestedName:e.targetDetail.file,accepts:[{description:"HEX files",extensions:["hex"]}]},function(o){Z()||chrome.fileSystem.getDisplayPath(o,function(c){console.log("Saving firmware to:",c),chrome.fileSystem.isWritableEntry(o,function(h){if(h){const p=new Blob([e.intel_hex],{type:"text/plain"});o.createWriter(function(C){let L=!1;C.onerror=function(k){console.error(k)},C.onwriteend=function(){if(!L){L=!0,C.truncate(p.size);return}R.sendEvent(R.EVENT_CATEGORIES.FLASHING,"SaveFirmware",c)},C.write(p)},function(C){console.error(C)})}else console.log("You don't have write permissions for this file, sorry."),w(i.getMessage("firmwareFlasherWritePermissions"))})})})}),t("input.flash_on_connect").change(function(){if(t(this).is(":checked")){const c=function(){re.port_detected("flash_detected_device",function(h){const p=h[0];A.connect_lock?w(i.getMessage("firmwareFlasherPreviousDevice",[p])):(w(i.getMessage("firmwareFlasherFlashTrigger",[p])),console.log(`Detected: ${p} - triggering flash on connect`),A.timeout_add("initialization_timeout",function(){t("a.flash_firmware").click()},100)),c()},!1,!0)};c()}else re.flush_callbacks()}).change(),t(document).keypress(function(o){o.which===13&&t("a.flash_firmware").click()}),e.flashingMessage(i.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),A.content_ready(s)}e.releaseLoader.loadTargets(()=>{t("#content").load("./tabs/firmware_flasher.html",a)})};q.backupConfig=function(s){let e,a="",r=null;function l(g){r=g}function n(g){r&&r(g)}function d(g){const b=new Uint8Array(g.data);for(const S of b){const y=String.fromCharCode(S);switch(S){case 10:A.operating_system==="Windows"&&(n(a),a="");break;case 13:A.operating_system!=="Windows"&&(n(a),a="");break;default:a+=y}}}function _(){return new Promise(g=>{const b=new ArrayBuffer(1),S=new Uint8Array(b);a="",S[0]=35,P.send(b),A.timeout_add("enter_cli_mode_done",()=>{g()},500)})}function E(g,b){const S=new ArrayBuffer(g.length),y=new Uint8Array(S);for(let G=0;G<g.length;G++)y[G]=g.charCodeAt(G);P.send(S,b)}function T(g,b){E(`${g}
`,b)}function D(){let g=performance.now();const b=[],S="COMMAND_INTERVAL";return l(y=>{g=performance.now(),b.push(y)}),T("diff all defaults"),new Promise(y=>{A.interval_add(S,()=>{performance.now()-g>500&&(r=null,A.interval_remove(S),y(b))},500,!1)})}function V(){O.clearListeners();let g=15;setTimeout(()=>{const S=setInterval(function(){re.port_available&&(console.log(`Connection ready for flashing in ${g/10} seconds`),clearInterval(S),s()),g++},100)},1500)}function N(){P.disconnect(V),O.disconnect_cleanup()}function u(){f.firmware_flasher.allowBoardDetection=!1,_().then(D).then(g=>{const b="cli_backup",S="txt",y=g.join(`
`),G=Pe(b,S);return A.saveToTextFileDialog(y,G,S)}).then(()=>T("exit",N))}function v(g){g?(e=new be,P.onReceive.addListener(d),O.listen(e.process_data.bind(e)),u()):(w(i.getMessage("serialPortOpenFail")),s&&s())}const m=t("div#port-picker #port"),F=String(m.val());if(F!=="0"){const g=parseInt(t("#flash_manual_baud_rate").val())||115200;P.connect(F,{bitrate:g},v)}else w(i.getMessage("firmwareFlasherNoPortSelected"))};q.cleanup=function(s){re.flush_callbacks(),t(document).unbind("keypress"),t(document).off("click","span.progressLabel a"),R.resetFirmwareData(),s&&s()};q.enableFlashButton=function(s){t("a.flash_firmware").toggleClass("disabled",!s)};q.enableLoadRemoteFileButton=function(s){t("a.load_remote_file").toggleClass("disabled",!s)};q.enableLoadFileButton=function(s){t("a.load_file").toggleClass("disabled",!s)};q.enableDfuExitButton=function(s){t("a.exit_dfu").toggleClass("disabled",!s)};q.refresh=function(s){const e=this;A.tab_switch_cleanup(function(){e.initialize(),s&&s()})};q.showDialogVerifyBoard=function(s,e,a,r){const l=t("#dialog-verify-board")[0];t("#dialog-verify-board-content").html(i.getMessage("firmwareFlasherVerifyBoard",{selected_board:s,verified_board:e})),l.hasAttribute("open")||(l.showModal(),t("#dialog-verify-board-abort-confirmbtn").click(function(){l.close(),a()}),t("#dialog-verify-board-continue-confirmbtn").click(function(){l.close(),r()}))};q.FLASH_MESSAGE_TYPES={NEUTRAL:"NEUTRAL",VALID:"VALID",INVALID:"INVALID",ACTION:"ACTION"};q.flashingMessage=function(s,e){let a=this,r=t("span.progressLabel");switch(e){case a.FLASH_MESSAGE_TYPES.VALID:r.removeClass("invalid actionRequired").addClass("valid");break;case a.FLASH_MESSAGE_TYPES.INVALID:r.removeClass("valid actionRequired").addClass("invalid");break;case a.FLASH_MESSAGE_TYPES.ACTION:r.removeClass("valid invalid").addClass("actionRequired");break;case a.FLASH_MESSAGE_TYPES.NEUTRAL:default:r.removeClass("valid invalid actionRequired");break}return s!==null&&r.html(s),a};q.flashProgress=function(s){return t(".progress").val(s),this};q.injectTargetInfo=function(s,e,a,r){const l=/^# config: manufacturer_id: .*, board_name: .*, version: .*$, date: .*\n/gm,n=s.replace(l,""),d=`# config: manufacturer_id: ${a}, board_name: ${e}, version: ${r.commitHash}, date: ${r.date}`,_=n.split(`
`);return _.splice(1,0,d),_.join(`
`)};f.firmware_flasher=q;export{q as firmware_flasher};
