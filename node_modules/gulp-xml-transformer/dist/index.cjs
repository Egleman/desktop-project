'use strict';

var util = require('util');
var arrify = require('arrify');
var through = require('through2');
var vinylToString = require('vinyl-contents-tostring');
var PluginError = require('plugin-error');
var libxmljs = require('libxmljs2');
var normalize = require('value-or-function');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var arrify__default = /*#__PURE__*/_interopDefaultLegacy(arrify);
var through__default = /*#__PURE__*/_interopDefaultLegacy(through);
var vinylToString__default = /*#__PURE__*/_interopDefaultLegacy(vinylToString);
var PluginError__default = /*#__PURE__*/_interopDefaultLegacy(PluginError);
var libxmljs__default = /*#__PURE__*/_interopDefaultLegacy(libxmljs);
var normalize__default = /*#__PURE__*/_interopDefaultLegacy(normalize);

// eslint-disable-next-line import/prefer-default-export
const PLUGIN_NAME = 'gulp-xml-transformer';

const stringOrNumber = (...args) => normalize__default["default"](['number', 'string'], ...args);

// edit XML document by user specific function
const func = (tranformation) => (xml) => Promise.resolve(tranformation(xml, libxmljs__default["default"]))
  .then((newDoc) => newDoc.toString());

// edit XML document by user specific object
const obj = (transformations, nsUri) => (doc) => {
  transformations.forEach((transformation) => {
    const elem = (nsUri === undefined)
      ? doc.get(transformation.path)
      : doc.get(transformation.path, nsUri);
    const { isMandatory = true } = transformation;

    if (!(elem instanceof libxmljs__default["default"].Element)) {
      if (isMandatory) {
        throw new PluginError__default["default"](PLUGIN_NAME, `Can't find element at "${transformation.path}"`);
      }

      return;
    }

    if ({}.hasOwnProperty.call(transformation, 'text')) {
      elem.text(transformation.text);
    }

    const attrs = arrify__default["default"](transformation.attrs || transformation.attr);
    attrs.forEach((attr) => {
      Object.keys(attr).forEach((key) => {
        const oldAttr = elem.attr(key);
        const oldVal = oldAttr && oldAttr.value();
        const val = stringOrNumber(attr[key], oldVal);
        elem.attr({ [key]: val });
      });
    });
  });

  return doc.toString();
};

const clone = (fn) => (file, enc) => fn(file.clone(), enc);

const update = (file) => (xml) => Object.assign(file, {
  contents: file.isBuffer()
    ? Buffer.from(xml)
    : through__default["default"]().end(xml),
});

const getTransformStream = (transformer) => through__default["default"].obj(
  util.callbackify(clone((file, enc) => (
    file.isNull()
      ? Promise.resolve(file)
      : vinylToString__default["default"](file, enc)
        .then(libxmljs.parseXmlString)
        .then(transformer)
        .then(update(file))))),
);

var index = (transformations, nsUri) => {
  // check options
  switch (typeof transformations) {
    case 'function':
      return getTransformStream(func(transformations));
    case 'object':
      return getTransformStream(obj(arrify__default["default"](transformations), nsUri));
    case 'undefined':
      throw new PluginError__default["default"](PLUGIN_NAME, 'transformations option is required');
    default:
      throw new PluginError__default["default"](PLUGIN_NAME, 'transformations option must be a function or an object');
  }
};

module.exports = index;
//# sourceMappingURL=index.cjs.map
